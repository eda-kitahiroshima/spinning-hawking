<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0a0f1f" />
  <title>NEON CHANT — 8bit Rhythm</title>

  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700;800&family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg0:#070a16;
      --bg1:#0b1230;
      --bg2:#0b2033;

      --card: rgba(255,255,255,.07);
      --card2: rgba(255,255,255,.10);
      --stroke: rgba(255,255,255,.14);
      --stroke2: rgba(255,255,255,.18);

      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --muted2: rgba(255,255,255,.48);

      --pink:#ff3ea6;
      --cyan:#34d9ff;
      --lime:#5dff7b;
      --amber:#ffd86a;
      --violet:#a78bff;

      --danger:#ff5a7a;
      --ok:#55ffb4;

      --radius: 18px;
      --radius2: 24px;

      --shadow: 0 16px 52px rgba(0,0,0,.42);
      --shadow2: 0 10px 30px rgba(0,0,0,.34);

      --pixel: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      color:var(--text);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", sans-serif;
      background:
        radial-gradient(900px 700px at 15% -10%, rgba(52,217,255,.20), transparent 55%),
        radial-gradient(900px 700px at 90% 0%, rgba(255,62,166,.14), transparent 58%),
        radial-gradient(1000px 900px at 50% 115%, rgba(93,255,123,.12), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 50%, var(--bg2));
      overflow-x:hidden;
    }

    /* CRT overlay */
    .crt{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:0;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,.03) 0px,
          rgba(255,255,255,.03) 1px,
          rgba(0,0,0,0) 2px,
          rgba(0,0,0,0) 4px
        );
      mix-blend-mode: overlay;
      opacity:.35;
    }
    .vignette{
      position:fixed;
      inset:-40px;
      pointer-events:none;
      z-index:0;
      background: radial-gradient(1100px 900px at 50% 20%, rgba(255,255,255,.06), rgba(0,0,0,.44) 70%, rgba(0,0,0,.65));
      opacity:.55;
    }
    .spark{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:0;
      opacity:.35;
      background-image:
        radial-gradient(2px 2px at 12% 18%, rgba(255,255,255,.24), transparent 60%),
        radial-gradient(2px 2px at 38% 27%, rgba(52,217,255,.22), transparent 60%),
        radial-gradient(2px 2px at 66% 14%, rgba(255,216,106,.20), transparent 60%),
        radial-gradient(2px 2px at 81% 33%, rgba(255,62,166,.22), transparent 60%),
        radial-gradient(2px 2px at 22% 64%, rgba(93,255,123,.18), transparent 60%),
        radial-gradient(2px 2px at 74% 72%, rgba(167,139,255,.20), transparent 60%),
        radial-gradient(2px 2px at 54% 90%, rgba(255,255,255,.16), transparent 60%);
      animation: tw 2.6s ease-in-out infinite alternate;
    }
    @keyframes tw{ from{ transform: translateY(0); opacity:.32; } to{ transform: translateY(-6px); opacity:.42; } }

    .app{
      position:relative;
      z-index:1;
      min-height:100%;
      max-width: 1120px;
      margin: 0 auto;
      padding:
        max(14px, env(safe-area-inset-top))
        max(14px, env(safe-area-inset-right))
        max(14px, env(safe-area-inset-bottom))
        max(14px, env(safe-area-inset-left));
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 14px 14px;
      border: 1px solid var(--stroke);
      border-radius: var(--radius2);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      box-shadow: var(--shadow2);
      backdrop-filter: blur(12px);
    }

    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      min-width: 250px;
    }
    .mark{
      width:44px; height:44px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.22);
      background:
        radial-gradient(16px 16px at 25% 30%, rgba(255,255,255,.52), transparent 65%),
        linear-gradient(135deg, rgba(52,217,255,.92), rgba(255,62,166,.70) 55%, rgba(93,255,123,.60));
      box-shadow: 0 14px 30px rgba(0,0,0,.35);
      position:relative;
      overflow:hidden;
    }
    .mark::after{
      content:"";
      position:absolute;
      inset:-40%;
      background: radial-gradient(circle at 35% 35%, rgba(255,255,255,.26), transparent 55%);
      transform: rotate(18deg);
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:2px;
      line-height:1.1;
    }
    .title h1{
      margin:0;
      font-size: clamp(16px, 2.1vw, 20px);
      font-weight: 900;
      letter-spacing: .2px;
      display:flex;
      align-items:baseline;
      gap:10px;
      white-space:nowrap;
    }
    .pixel{
      font-family: var(--pixel);
      font-size: .82em;
      letter-spacing: .5px;
      opacity:.92;
    }
    .title p{
      margin:0;
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 52vw;
    }

    .actions{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    button, select, input[type="range"]{
      font: inherit;
      color: var(--text);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      box-shadow: 0 10px 22px rgba(0,0,0,.20);
      -webkit-tap-highlight-color: transparent;
    }
    button{
      padding: 10px 12px;
      cursor:pointer;
      transition: transform .08s ease, filter .12s ease;
      user-select:none;
    }
    button:hover{ filter: brightness(1.06); }
    button:active{ transform: translateY(1px) scale(.99); }
    button:focus-visible, select:focus-visible, input[type="range"]:focus-visible{
      outline: 2px solid rgba(52,217,255,.65);
      outline-offset: 2px;
    }

    .primary{
      background: linear-gradient(180deg, rgba(52,217,255,.30), rgba(93,255,123,.20));
      border-color: rgba(52,217,255,.42);
    }
    .danger{
      background: linear-gradient(180deg, rgba(255,90,122,.28), rgba(255,90,122,.14));
      border-color: rgba(255,90,122,.40);
    }
    .ghost{
      background: rgba(255,255,255,.06);
      box-shadow:none;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--muted);
      font-size: 12px;
      white-space:nowrap;
    }
    .dot{
      width:9px;height:9px;border-radius:999px;
      background: var(--ok);
      box-shadow: 0 0 0 4px rgba(85,255,180,.14);
    }
    .dot.paused{ background: var(--amber); box-shadow: 0 0 0 4px rgba(255,216,106,.14); }
    .dot.dead{ background: var(--danger); box-shadow: 0 0 0 4px rgba(255,90,122,.14); }

    .grid{
      display:grid;
      grid-template-columns: 1.12fr .88fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
      .title p{ max-width: 72vw; }
    }

    .card{
      border: 1px solid var(--stroke);
      border-radius: var(--radius2);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      box-shadow: var(--shadow2);
      backdrop-filter: blur(12px);
    }

    .stage{
      padding: 14px;
      position:relative;
    }
    .stageWrap{
      width:100%;
      aspect-ratio: 10 / 16;
      max-height: min(74vh, 760px);
      margin: 0 auto;
      border-radius: 18px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.16);
      background:
        radial-gradient(700px 500px at 50% 0%, rgba(52,217,255,.18), transparent 60%),
        radial-gradient(900px 700px at 70% 40%, rgba(255,62,166,.12), transparent 62%),
        linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.40));
      position:relative;
      touch-action:none;
    }
    canvas{ width:100%; height:100%; display:block; }

    .overlay{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      background: radial-gradient(900px 600px at 50% 38%, rgba(7,10,22,.58), rgba(7,10,22,.88));
      backdrop-filter: blur(8px);
    }
    .overlayInner{
      width:min(560px, 92%);
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.18);
      background: linear-gradient(180deg, rgba(255,255,255,.11), rgba(255,255,255,.06));
      box-shadow: var(--shadow);
      padding: 18px 18px 16px;
      text-align:center;
    }
    .overlayInner h2{
      margin: 6px 0 8px;
      font-size: 16px;
      letter-spacing:.2px;
      font-family: var(--pixel);
    }
    .overlayInner p{
      margin: 0 0 14px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.6;
    }
    .overlayRow{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
      margin-top: 12px;
    }
    .overlayRow button{ min-width: 160px; }
    .overlaySmall{
      margin-top: 10px;
      color: rgba(255,255,255,.58);
      font-size: 12px;
    }

    .side{
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    .panel{
      padding: 14px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .panelHead{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
    }
    .panelHead h2{
      margin:0;
      font-size: 14px;
      letter-spacing:.2px;
      font-family: var(--pixel);
      font-weight: 400;
    }
    .sub{
      font-size: 12px;
      color: var(--muted2);
    }

    .stats{
      padding: 14px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .stat{
      padding: 12px 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      min-height: 70px;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      gap:6px;
    }
    .stat span{
      font-size: 12px;
      color: var(--muted2);
    }
    .stat strong{
      font-size: 18px;
      letter-spacing:.2px;
    }
    .stat strong.small{ font-size: 15px; }
    .stat.full{ grid-column: 1 / -1; }

    .settings{
      padding: 14px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .row label{
      font-size: 12px;
      color: var(--muted);
      display:flex;
      align-items:center;
      gap:10px;
      white-space:nowrap;
    }
    select{
      padding: 10px 12px;
      background: rgba(255,255,255,.08);
      border-color: rgba(255,255,255,.18);
      cursor:pointer;
      min-width: 160px;
    }
    input[type="range"]{
      width: 220px;
      height: 30px;
      padding: 0 10px;
      background: rgba(255,255,255,.06);
      box-shadow:none;
    }
    .rangeVal{
      font-family: var(--pixel);
      font-size: 11px;
      color: rgba(255,255,255,.78);
      min-width: 90px;
      text-align:right;
    }

    .help{
      padding: 14px;
    }
    .help h3{
      margin:0 0 10px;
      font-size: 13px;
      letter-spacing:.2px;
      font-family: var(--pixel);
      font-weight: 400;
    }
    .help ul{
      margin:0;
      padding-left: 18px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.6;
    }
    .kbd{
      font-family: var(--pixel);
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.84);
      white-space:nowrap;
      display:inline-block;
      transform: translateY(-1px);
    }

    .pads{
      padding: 12px;
      position:sticky;
      bottom: max(10px, env(safe-area-inset-bottom));
      z-index: 5;
    }
    .padGrid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
    }
    .padBtn{
      min-height: 58px;
      border-radius: 18px;
      padding: 12px 10px;
      font-weight: 900;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:6px;
      user-select:none;
      touch-action: manipulation;
      position:relative;
      overflow:hidden;
    }
    .padBtn .p1{ font-family: var(--pixel); font-size: 10px; opacity:.9; }
    .padBtn .p2{ font-size: 12px; color: rgba(255,255,255,.74); font-weight: 800; }
    .padBtn::after{
      content:"";
      position:absolute;
      inset:-40%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.18), transparent 55%);
      transform: rotate(12deg);
      opacity:.7;
      pointer-events:none;
    }
    .padBtn.hit{
      filter: brightness(1.18);
      transform: translateY(1px) scale(.99);
    }

    .toast{
      position:fixed;
      left:50%;
      bottom: 16px;
      transform: translateX(-50%);
      width: min(560px, calc(100vw - 24px));
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(7,10,22,.78);
      color: rgba(255,255,255,.92);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(10px);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      z-index: 99;
      font-size: 13px;
      line-height: 1.35;
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-6px);
    }

    .sr-only{
      position:absolute!important;
      width:1px;height:1px;
      padding:0;margin:-1px;
      overflow:hidden;clip:rect(0,0,0,0);
      border:0;
    }
  </style>
</head>

<body>
  <div class="spark" aria-hidden="true"></div>
  <div class="crt" aria-hidden="true"></div>
  <div class="vignette" aria-hidden="true"></div>

  <div class="app">
    <header class="topbar">
      <div class="brand">
        <div class="mark" aria-hidden="true"></div>
        <div class="title">
          <h1>NEON CHANT <span class="pixel">— 8bit Rhythm</span></h1>
          <p>ライブ会場で盛り上がる “合いの手” リズム。タップでノーツを叩け！</p>
        </div>
      </div>

      <div class="actions">
        <div class="pill" title="状態">
          <span class="dot" id="statusDot" aria-hidden="true"></span>
          <span id="statusText">READY</span>
        </div>
        <button class="primary" id="btnStart" type="button">Start</button>
        <button id="btnPause" type="button">Pause</button>
        <button class="ghost" id="btnSound" type="button">Sound: On</button>
      </div>
    </header>

    <main class="grid">
      <section class="card stage">
        <div class="stageWrap" id="stageWrap">
          <canvas id="cv" aria-label="ゲーム画面" role="img"></canvas>

          <div class="overlay" id="overlay">
            <div class="overlayInner">
              <h2 id="ovTitle">READY?</h2>
              <p id="ovDesc">音が鳴らないときは、まず <b>Start</b> を押して音声を有効化してください。</p>
              <div class="overlayRow">
                <button class="primary" id="ovMain" type="button">Start</button>
                <button class="ghost" id="ovHow" type="button">How to</button>
              </div>
              <div class="overlaySmall" id="ovSmall">
                キー操作：<span class="kbd">D</span><span class="kbd">F</span><span class="kbd">J</span><span class="kbd">K</span> ／ 停止：<span class="kbd">P</span>
              </div>
            </div>
          </div>
        </div>
      </section>

      <aside class="side">
        <section class="card stats" aria-label="スコア情報">
          <div class="stat">
            <span>Score</span>
            <strong id="uiScore">0</strong>
          </div>
          <div class="stat">
            <span>Combo</span>
            <strong id="uiCombo">0</strong>
          </div>
          <div class="stat">
            <span>Accuracy</span>
            <strong id="uiAcc">0%</strong>
          </div>
          <div class="stat">
            <span>Rank</span>
            <strong id="uiRank">—</strong>
          </div>
          <div class="stat full">
            <span>Judgement</span>
            <strong class="small" id="uiJudge">—</strong>
          </div>
          <div class="stat full">
            <span>High Score</span>
            <strong class="small" id="uiHigh">0</strong>
          </div>
        </section>

        <section class="card settings" aria-label="設定">
          <div class="panelHead">
            <h2>SETTINGS</h2>
            <span class="sub">調整</span>
          </div>

          <div class="row">
            <label>Difficulty</label>
            <select id="selDiff" aria-label="難易度">
              <option value="easy">Easy</option>
              <option value="normal" selected>Normal</option>
              <option value="hard">Hard</option>
            </select>
          </div>

          <div class="row">
            <label>Timing Offset</label>
            <input id="rngOffset" type="range" min="-150" max="150" step="5" value="0" aria-label="タイミング調整(ms)">
            <div class="rangeVal" id="valOffset">0ms</div>
          </div>

          <div class="row">
            <label>SE Volume</label>
            <input id="rngVol" type="range" min="0" max="100" step="1" value="70" aria-label="音量">
            <div class="rangeVal" id="valVol">70%</div>
          </div>

          <div class="row">
            <button class="ghost" id="btnRegen" type="button">Rebuild Chart</button>
            <button class="danger" id="btnResetHigh" type="button">Reset High</button>
          </div>
        </section>

        <section class="card help">
          <h3>操作</h3>
          <ul>
            <li>ノーツがラインに来たら、レーンをタップ（または <span class="kbd">D</span><span class="kbd">F</span><span class="kbd">J</span><span class="kbd">K</span>）</li>
            <li>止める：<span class="kbd">P</span> ／ 再開：<span class="kbd">P</span> または <span class="kbd">Start</span></li>
            <li>ずれて感じたら Timing Offset を調整（+で遅く / -で早く判定）</li>
          </ul>
        </section>
      </aside>
    </main>

    <footer class="card pads" aria-label="タッチ操作ボタン">
      <div class="padGrid">
        <button class="padBtn" data-lane="0" type="button" aria-label="Lane 1">
          <div class="p1">LANE 1</div><div class="p2">D</div>
        </button>
        <button class="padBtn" data-lane="1" type="button" aria-label="Lane 2">
          <div class="p1">LANE 2</div><div class="p2">F</div>
        </button>
        <button class="padBtn" data-lane="2" type="button" aria-label="Lane 3">
          <div class="p1">LANE 3</div><div class="p2">J</div>
        </button>
        <button class="padBtn" data-lane="3" type="button" aria-label="Lane 4">
          <div class="p1">LANE 4</div><div class="p2">K</div>
        </button>
      </div>
      <div class="sr-only" id="ariaLive" aria-live="polite"></div>
    </footer>

    <div class="toast" id="toast" role="status" aria-live="polite"></div>
  </div>

  <script>
    (() => {
      "use strict";

      // ===== Helpers =====
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const now = () => (performance && performance.now) ? performance.now() : Date.now();

      // ===== DOM =====
      const cv = document.getElementById("cv");
      const stageWrap = document.getElementById("stageWrap");

      const overlay = document.getElementById("overlay");
      const ovTitle = document.getElementById("ovTitle");
      const ovDesc  = document.getElementById("ovDesc");
      const ovMain  = document.getElementById("ovMain");
      const ovHow   = document.getElementById("ovHow");
      const ovSmall = document.getElementById("ovSmall");

      const btnStart = document.getElementById("btnStart");
      const btnPause = document.getElementById("btnPause");
      const btnSound = document.getElementById("btnSound");

      const statusDot = document.getElementById("statusDot");
      const statusText = document.getElementById("statusText");

      const uiScore = document.getElementById("uiScore");
      const uiCombo = document.getElementById("uiCombo");
      const uiAcc   = document.getElementById("uiAcc");
      const uiRank  = document.getElementById("uiRank");
      const uiJudge = document.getElementById("uiJudge");
      const uiHigh  = document.getElementById("uiHigh");

      const selDiff = document.getElementById("selDiff");
      const rngOffset = document.getElementById("rngOffset");
      const valOffset = document.getElementById("valOffset");
      const rngVol = document.getElementById("rngVol");
      const valVol = document.getElementById("valVol");
      const btnRegen = document.getElementById("btnRegen");
      const btnResetHigh = document.getElementById("btnResetHigh");

      const toastEl = document.getElementById("toast");
      const ariaLive = document.getElementById("ariaLive");

      const pads = Array.from(document.querySelectorAll(".padBtn"));

      const ctx = (() => {
        try { return cv.getContext("2d", { alpha: true }); } catch(e){ return null; }
      })();

      function toast(msg, ms=1600){
        try{
          if (!toastEl) return;
          toastEl.textContent = msg;
          toastEl.classList.add("show");
          clearTimeout(toast._t);
          toast._t = setTimeout(() => toastEl.classList.remove("show"), ms);
          if (ariaLive) ariaLive.textContent = msg;
        }catch(_){}
      }

      // ===== LocalStorage =====
      const LS = (() => {
        try{
          const t="__nc_test__";
          localStorage.setItem(t,"1");
          localStorage.removeItem(t);
          return localStorage;
        }catch(_){ return null; }
      })();

      const KEYS = {
        settings: "neonchant_settings_v1",
        high: "neonchant_high_v1"
      };

      function loadJSON(key, fallback){
        if (!LS) return fallback;
        try{
          const raw = LS.getItem(key);
          if (!raw) return fallback;
          const v = JSON.parse(raw);
          return (v === null || v === undefined) ? fallback : v;
        }catch(_){ return fallback; }
      }
      function saveJSON(key, value){
        if (!LS) return false;
        try{ LS.setItem(key, JSON.stringify(value)); return true; }catch(_){ return false; }
      }

      // ===== Settings =====
      const settings = Object.assign({
        sound: true,
        diff: "normal",
        offsetMs: 0,
        vol: 0.7
      }, loadJSON(KEYS.settings, {}));

      function persistSettings(){
        const ok = saveJSON(KEYS.settings, settings);
        if (!ok && LS) toast("設定の保存に失敗しました（容量/制限）");
      }

      function syncSettingsUI(){
        selDiff.value = settings.diff;
        rngOffset.value = String(settings.offsetMs|0);
        valOffset.textContent = `${settings.offsetMs|0}ms`;
        rngVol.value = String(Math.round(settings.vol * 100));
        valVol.textContent = `${Math.round(settings.vol * 100)}%`;
        btnSound.textContent = "Sound: " + (settings.sound ? "On" : "Off");
      }

      let highScore = Number(loadJSON(KEYS.high, 0)) || 0;
      uiHigh.textContent = String(highScore);

      // ===== Status =====
      function setStatus(kind){
        // kind: ready|run|pause|dead
        statusDot.classList.remove("paused","dead");
        if (kind === "ready"){
          statusText.textContent = "READY";
        }else if (kind === "run"){
          statusText.textContent = "PLAYING";
        }else if (kind === "pause"){
          statusText.textContent = "PAUSED";
          statusDot.classList.add("paused");
        }else{
          statusText.textContent = "FINISH";
          statusDot.classList.add("dead");
        }
      }

      // ===== Audio =====
      let audioCtx = null;
      let master = null, sfxGain = null, musicGain = null;
      let audioOk = false;

      function ensureAudio(){
        if (audioCtx) return audioCtx;
        try{
          const Ctx = window.AudioContext || window.webkitAudioContext;
          if (!Ctx) return null;
          audioCtx = new Ctx();
          master = audioCtx.createGain();
          sfxGain = audioCtx.createGain();
          musicGain = audioCtx.createGain();

          master.gain.value = 0.9;
          sfxGain.gain.value = settings.sound ? settings.vol : 0;
          musicGain.gain.value = settings.sound ? Math.min(0.55, settings.vol * 0.75) : 0;

          sfxGain.connect(master);
          musicGain.connect(master);
          master.connect(audioCtx.destination);
          audioOk = true;
          return audioCtx;
        }catch(e){
          audioOk = false;
          return null;
        }
      }

      async function unlockAudio(){
        const ac = ensureAudio();
        if (!ac) return false;
        try{
          if (ac.state === "suspended") await ac.resume();
          return true;
        }catch(_){ return false; }
      }

      function setVolumes(){
        if (!sfxGain || !musicGain) return;
        const v = settings.sound ? clamp(settings.vol, 0, 1) : 0;
        sfxGain.gain.value = v;
        musicGain.gain.value = Math.min(0.55, v * 0.75);
      }

      function oscBeep({t, freq=440, dur=0.05, type="square", gain=0.06, to= "sfx"}){
        if (!settings.sound) return;
        const ac = ensureAudio();
        if (!ac || !audioOk) return;
        try{
          const o = ac.createOscillator();
          const g = ac.createGain();
          o.type = type;
          o.frequency.setValueAtTime(freq, t);

          const A = 0.004, R = Math.max(0.006, dur * 0.35);
          g.gain.setValueAtTime(0.0001, t);
          g.gain.exponentialRampToValueAtTime(gain, t + A);
          g.gain.exponentialRampToValueAtTime(0.0001, t + dur + R);

          o.connect(g);
          (to === "music" ? musicGain : sfxGain).connect ? g.connect((to === "music" ? musicGain : sfxGain)) : g.connect(ac.destination);

          o.start(t);
          o.stop(t + dur + R + 0.02);
        }catch(_){}
      }

      function noiseHit({t, dur=0.04, gain=0.05, tone=1200, to="music"}){
        if (!settings.sound) return;
        const ac = ensureAudio();
        if (!ac || !audioOk) return;
        try{
          const bufferSize = Math.floor(ac.sampleRate * dur);
          const buffer = ac.createBuffer(1, bufferSize, ac.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i=0; i<bufferSize; i++){
            const n = (Math.random()*2 - 1);
            data[i] = n * Math.pow(1 - i / bufferSize, 2.2);
          }
          const src = ac.createBufferSource();
          src.buffer = buffer;

          const bp = ac.createBiquadFilter();
          bp.type = "bandpass";
          bp.frequency.setValueAtTime(tone, t);
          bp.Q.setValueAtTime(5, t);

          const g = ac.createGain();
          g.gain.setValueAtTime(gain, t);
          g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

          src.connect(bp);
          bp.connect(g);
          g.connect(to === "music" ? musicGain : sfxGain);

          src.start(t);
          src.stop(t + dur + 0.01);
        }catch(_){}
      }

      function sfx(type){
        const ac = ensureAudio();
        if (!ac || !audioOk || !settings.sound) return;

        const t = ac.currentTime;
        if (type === "perfect"){
          oscBeep({t, freq: 880, dur: 0.04, type:"square", gain: 0.07, to:"sfx"});
          oscBeep({t: t+0.03, freq: 1175, dur: 0.05, type:"square", gain: 0.05, to:"sfx"});
        }else if (type === "great"){
          oscBeep({t, freq: 740, dur: 0.05, type:"square", gain: 0.06, to:"sfx"});
        }else if (type === "good"){
          oscBeep({t, freq: 520, dur: 0.05, type:"square", gain: 0.05, to:"sfx"});
        }else if (type === "miss"){
          oscBeep({t, freq: 160, dur: 0.09, type:"sawtooth", gain: 0.06, to:"sfx"});
        }else if (type === "start"){
          oscBeep({t, freq: 440, dur: 0.06, type:"square", gain: 0.06, to:"sfx"});
          oscBeep({t: t+0.06, freq: 660, dur: 0.06, type:"square", gain: 0.06, to:"sfx"});
          oscBeep({t: t+0.12, freq: 880, dur: 0.06, type:"square", gain: 0.06, to:"sfx"});
        }else if (type === "pause"){
          oscBeep({t, freq: 330, dur: 0.05, type:"square", gain: 0.05, to:"sfx"});
          oscBeep({t: t+0.06, freq: 220, dur: 0.06, type:"square", gain: 0.05, to:"sfx"});
        }else if (type === "resume"){
          oscBeep({t, freq: 220, dur: 0.05, type:"square", gain: 0.05, to:"sfx"});
          oscBeep({t: t+0.06, freq: 330, dur: 0.06, type:"square", gain: 0.05, to:"sfx"});
        }else if (type === "finish"){
          oscBeep({t, freq: 784, dur: 0.06, type:"square", gain: 0.06, to:"sfx"});
          oscBeep({t: t+0.07, freq: 659, dur: 0.06, type:"square", gain: 0.05, to:"sfx"});
          oscBeep({t: t+0.14, freq: 523, dur: 0.10, type:"square", gain: 0.05, to:"sfx"});
        }else if (type === "combo"){
          oscBeep({t, freq: 988, dur: 0.03, type:"square", gain: 0.05, to:"sfx"});
        }
      }

      // ===== Song / Scheduling =====
      const BPM = 140;
      const BEAT = 60 / BPM;      // seconds per beat
      const STEP = BEAT / 4;      // 16th note
      const SONG_BEATS = 4 * 24;  // 24 measures (4 beats each) => ~41s
      const SONG_SEC = SONG_BEATS * BEAT;

      let songStartTime = 0; // audioCtx time
      let songRunning = false;
      let schedTimer = 0;
      let schedPtr = 0;      // step pointer for music
      let schedEndTime = 0;

      function midiToFreq(m){ return 440 * Math.pow(2, (m - 69) / 12); }

      // 8-bit-ish chord progression (in semitones): Cm, Ab, Bb, G (loop)
      const PROG = [
        [60, 63, 67], // C Eb G
        [56, 60, 63], // Ab C Eb
        [58, 62, 65], // Bb D F
        [55, 59, 62], // G B D
      ];
      const ARP = [0,1,2,1,0,2,1,2]; // step pattern (8 steps per measure-ish)
      const DRUM = {
        kick: [1,0,0,0, 0,0,1,0, 1,0,0,0, 0,0,1,0],
        snare:[0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
        hat:  [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1]
      };

      function scheduleMusic(fromTime, toTime){
        const ac = ensureAudio();
        if (!ac || !audioOk) return;
        const lookStart = fromTime;
        const lookEnd = toTime;

        const start = songStartTime;
        const totalSteps = SONG_BEATS * 4; // 16th steps count

        while (schedPtr < totalSteps){
          const t = start + schedPtr * STEP;
          if (t < lookStart){ schedPtr++; continue; }
          if (t > lookEnd) break;

          // Determine measure & step in measure
          const stepInMeasure = schedPtr % 16;
          const measure = Math.floor(schedPtr / 16);
          const chord = PROG[measure % PROG.length];

          // Arp every 2 steps (8th)
          if ((stepInMeasure % 2) === 0){
            const idx = ARP[(stepInMeasure/2) % ARP.length] | 0;
            const note = chord[idx] + 12; // brighten
            oscBeep({ t, freq: midiToFreq(note), dur: STEP * 1.2, type:"square", gain: 0.045, to:"music" });
          }

          // Bass on beats
          if ((stepInMeasure % 4) === 0){
            const bass = chord[0] - 12;
            oscBeep({ t, freq: midiToFreq(bass), dur: STEP * 1.8, type:"triangle", gain: 0.032, to:"music" });
          }

          // Drums
          if (DRUM.hat[stepInMeasure]) noiseHit({ t, dur: 0.025, gain: 0.018, tone: 5000, to:"music" });
          if (DRUM.kick[stepInMeasure]){
            // kick: falling sine
            try{
              const o = ac.createOscillator();
              const g = ac.createGain();
              o.type = "sine";
              o.frequency.setValueAtTime(140, t);
              o.frequency.exponentialRampToValueAtTime(52, t + 0.09);
              g.gain.setValueAtTime(0.0001, t);
              g.gain.exponentialRampToValueAtTime(0.09, t + 0.004);
              g.gain.exponentialRampToValueAtTime(0.0001, t + 0.11);
              o.connect(g);
              g.connect(musicGain);
              o.start(t);
              o.stop(t + 0.14);
            }catch(_){}
          }
          if (DRUM.snare[stepInMeasure]){
            noiseHit({ t, dur: 0.055, gain: 0.05, tone: 1600, to:"music" });
          }

          schedPtr++;
        }
      }

      function startMusic(){
        const ac = ensureAudio();
        if (!ac || !audioOk) return false;

        // reset scheduling
        schedPtr = 0;
        songStartTime = ac.currentTime + 0.12; // small lead-in
        schedEndTime = songStartTime + SONG_SEC + 0.25;
        songRunning = true;

        clearInterval(schedTimer);
        schedTimer = setInterval(() => {
          if (!songRunning) return;
          const t0 = ac.currentTime;
          const lookAhead = 0.18;
          scheduleMusic(t0, t0 + lookAhead);

          if (t0 > schedEndTime){
            // stop later by game end; keep safe
            songRunning = false;
            clearInterval(schedTimer);
          }
        }, 60);

        return true;
      }

      function stopMusic(){
        songRunning = false;
        clearInterval(schedTimer);
        schedTimer = 0;
      }

      // ===== Game =====
      const LANES = 4;
      const LANE_COLS = ["#34d9ff", "#ff3ea6", "#5dff7b", "#a78bff"];

      const LEAD_MS = 1500;          // note travel time
      const HITLINE_Y = 0.82;        // relative position
      const WINDOWS = {
        perfect: 35,
        great: 75,
        good: 120,
        miss: 160
      };

      const RANKS = [
        { name:"S", min: 98 },
        { name:"A", min: 92 },
        { name:"B", min: 84 },
        { name:"C", min: 72 },
        { name:"D", min: 0 }
      ];

      let running = false;
      let paused = false;
      let finished = false;

      let startPerf = 0;   // fallback clock base
      let pausePerf = 0;
      let pauseAccum = 0;

      let chart = [];      // {t:ms, lane, hit:false, judged:false, j:"", delta:ms}
      let idxFirstActive = 0;

      let score = 0;
      let combo = 0;
      let maxCombo = 0;

      let hitCount = 0;
      let totalCount = 0;
      let weighted = 0; // 1.0 perfect, 0.8 great, 0.5 good

      let lastJudgeText = "—";
      let laneFlash = new Array(LANES).fill(0); // 0..1 decay
      let lastFrameT = now();

      // Canvas sizing
      let rect = { cssW: 1, cssH: 1, dpr: 1 };

      function fitCanvas(){
        if (!ctx) return;
        const dpr = window.devicePixelRatio || 1;
        const r = cv.getBoundingClientRect();
        const w = Math.max(1, Math.round(r.width * dpr));
        const h = Math.max(1, Math.round(r.height * dpr));
        if (cv.width !== w || cv.height !== h){
          cv.width = w;
          cv.height = h;
        }
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.imageSmoothingEnabled = true;
        rect = { cssW: r.width, cssH: r.height, dpr };
      }

      function seededRand(seed){
        // simple LCG
        let s = seed >>> 0;
        return () => {
          s = (s * 1664525 + 1013904223) >>> 0;
          return (s / 4294967296);
        };
      }

      function buildChart(diff){
        const seed = (Date.now() ^ (highScore|0) ^ (diff.charCodeAt(0) << 16)) >>> 0;
        const rnd = seededRand(seed);

        const beats = SONG_BEATS; // number of beats
        const notes = [];
        const msPerBeat = 60000 / BPM;
        const steps = beats * 4;

        // density per difficulty
        const p = diff === "easy" ? { base: 0.55, sync: 0.10 } :
                  diff === "hard" ? { base: 0.92, sync: 0.38 } :
                                    { base: 0.78, sync: 0.22 };

        let lastLane = -1;

        for (let s=0; s<steps; s++){
          const stepInBeat = s % 4;
          const beatIndex = Math.floor(s / 4);

          // avoid placing too early; add 1 beat lead (but still okay)
          const t = (s * msPerBeat / 4);

          // downbeat emphasis and chant-like rhythm:
          // always something on beat in normal/hard, sometimes in easy
          let place = false;
          if (stepInBeat === 0){
            const must = (diff !== "easy") || (rnd() < 0.82);
            place = must;
          }else{
            // syncopation
            place = (rnd() < p.sync);
          }

          // add occasional double on "and" for hard
          if (!place && diff === "hard" && (stepInBeat === 2) && rnd() < 0.30) place = true;

          // reduce too-empty measures
          if (!place && (beatIndex % 4 === 3) && stepInBeat === 0 && rnd() < 0.55) place = true;

          if (!place) continue;

          // choose lane with bias to alternate
          let lane = (rnd() * LANES) | 0;
          if (lane === lastLane && rnd() < 0.72){
            lane = (lane + 1 + ((rnd()*3)|0)) % LANES;
          }
          lastLane = lane;

          // prevent impossible spam in easy
          if (diff === "easy" && stepInBeat !== 0 && rnd() < 0.35) continue;

          notes.push({ t, lane, judged:false, hit:false, j:"", delta:0 });
        }

        // ensure at least some notes
        if (notes.length < 40){
          // fallback: one per beat
          const fallback = [];
          for (let b=0; b<beats; b++){
            fallback.push({ t: b*msPerBeat, lane: (b % LANES), judged:false, hit:false, j:"", delta:0 });
          }
          return fallback;
        }

        // sort and assign count
        notes.sort((a,b)=>a.t-b.t);
        return notes;
      }

      function resetRun(){
        score = 0;
        combo = 0;
        maxCombo = 0;
        hitCount = 0;
        totalCount = 0;
        weighted = 0;
        lastJudgeText = "—";
        uiJudge.textContent = lastJudgeText;

        laneFlash.fill(0);
        idxFirstActive = 0;
        pauseAccum = 0;
      }

      function currentTimeMs(){
        // Prefer audio clock if running & valid; fallback to performance-based
        if (audioCtx && running){
          const t = (audioCtx.currentTime - songStartTime) * 1000;
          return t;
        }
        return (now() - startPerf) - pauseAccum;
      }

      function showOverlay(title, desc, mainLabel){
        ovTitle.textContent = title;
        ovDesc.innerHTML = desc;
        ovMain.textContent = mainLabel;
        overlay.hidden = false;
      }
      function hideOverlay(){ overlay.hidden = true; }

      function updateUI(){
        uiScore.textContent = String(score|0);
        uiCombo.textContent = String(combo|0);

        const acc = (totalCount > 0) ? (weighted / totalCount) * 100 : 0;
        uiAcc.textContent = `${acc.toFixed(1)}%`;

        const rank = RANKS.find(r => acc >= r.min) || RANKS[RANKS.length-1];
        uiRank.textContent = rank.name;
        uiJudge.textContent = lastJudgeText;

        if (score > highScore){
          highScore = score;
          uiHigh.textContent = String(highScore);
          saveJSON(KEYS.high, highScore);
        }
      }

      function judgeText(kind, delta){
        const sign = delta > 0 ? "+" : "";
        const d = Math.abs(delta);
        if (kind === "MISS") return `MISS (${sign}${delta}ms)`;
        return `${kind} (${sign}${delta}ms)`;
      }

      function applyJudge(kind, delta){
        lastJudgeText = judgeText(kind, delta);
        uiJudge.textContent = lastJudgeText;

        if (kind === "PERFECT"){
          hitCount++; totalCount++; weighted += 1.0;
          combo++;
          score += 100 + Math.min(250, combo * 2);
          sfx("perfect");
        }else if (kind === "GREAT"){
          hitCount++; totalCount++; weighted += 0.8;
          combo++;
          score += 70 + Math.min(180, combo * 2);
          sfx("great");
        }else if (kind === "GOOD"){
          hitCount++; totalCount++; weighted += 0.5;
          combo++;
          score += 40 + Math.min(120, combo * 2);
          sfx("good");
        }else{
          totalCount++;
          combo = 0;
          sfx("miss");
        }

        if (combo > maxCombo) maxCombo = combo;
        if (combo > 0 && (combo % 25) === 0) sfx("combo");

        updateUI();
      }

      function noteWindow(delta){
        const ad = Math.abs(delta);
        if (ad <= WINDOWS.perfect) return "PERFECT";
        if (ad <= WINDOWS.great) return "GREAT";
        if (ad <= WINDOWS.good) return "GOOD";
        if (ad <= WINDOWS.miss) return "MISS";
        return null;
      }

      function hitLane(lane){
        if (!running || paused || finished) return;

        // visual flash for pads
        laneFlash[lane] = 1;

        const t = currentTimeMs() + (settings.offsetMs|0);
        // find nearest unjudged note in this lane around time
        const searchStart = Math.max(0, idxFirstActive - 10);
        const searchEnd = Math.min(chart.length, idxFirstActive + 30);

        let bestIdx = -1;
        let bestDelta = 999999;

        for (let i=searchStart; i<searchEnd; i++){
          const n = chart[i];
          if (!n || n.judged) continue;
          if (n.lane !== lane) continue;
          const delta = t - n.t;
          const ad = Math.abs(delta);
          if (ad <= WINDOWS.miss && ad < bestDelta){
            bestDelta = ad;
            bestIdx = i;
          }
          // early break if notes are far in future
          if (n.t - t > WINDOWS.miss + 220) break;
        }

        if (bestIdx >= 0){
          const n = chart[bestIdx];
          const delta = Math.round((t - n.t));
          const kind = noteWindow(delta) || "MISS";
          n.judged = true;
          n.hit = kind !== "MISS";
          n.j = kind;
          n.delta = delta;

          applyJudge(kind, delta);
        }else{
          // empty hit (no note) => light penalty on normal/hard
          if (settings.diff !== "easy"){
            applyJudge("MISS", 0);
          }else{
            // soft feedback only
            lastJudgeText = "—";
            uiJudge.textContent = lastJudgeText;
            sfx("good");
          }
        }
      }

      function missPassedNotes(){
        const t = currentTimeMs() + (settings.offsetMs|0);

        // advance idxFirstActive
        while (idxFirstActive < chart.length && chart[idxFirstActive].t < (t - LEAD_MS - 600)){
          idxFirstActive++;
        }

        // mark misses when past window
        const limit = Math.min(chart.length, idxFirstActive + 80);
        for (let i=idxFirstActive; i<limit; i++){
          const n = chart[i];
          if (!n || n.judged) continue;
          const delta = t - n.t;
          if (delta > WINDOWS.miss){
            n.judged = true;
            n.hit = false;
            n.j = "MISS";
            n.delta = Math.round(delta);
            applyJudge("MISS", Math.round(delta));
          }else{
            // chart is time-sorted; if this isn't late, later won't be either
            break;
          }
        }
      }

      function finishGame(){
        running = false;
        paused = false;
        finished = true;
        stopMusic();
        setStatus("dead");
        sfx("finish");

        const acc = (totalCount > 0) ? (weighted / totalCount) * 100 : 0;
        const rank = (RANKS.find(r => acc >= r.min) || RANKS[RANKS.length-1]).name;

        const msg =
          `おつかれ！<br>` +
          `Score: <b>${score|0}</b> / Max Combo: <b>${maxCombo|0}</b><br>` +
          `Accuracy: <b>${acc.toFixed(1)}%</b> / Rank: <b>${rank}</b><br>` +
          `<span style="color:rgba(255,255,255,.62)">もう一回いく？</span>`;

        showOverlay("FINISH!", msg, "Retry");
        ovSmall.textContent = "キー：D F J K ／ Retry：Enter";
      }

      function startGame(){
        // build chart
        chart = buildChart(settings.diff);
        resetRun();
        updateUI();

        running = true;
        paused = false;
        finished = false;

        setStatus("run");
        hideOverlay();

        // start clocks
        startPerf = now();
        pausePerf = 0;
        pauseAccum = 0;

        // audio start
        if (audioCtx){
          // if restarting, recreate scheduling
          startMusic();
        }

        sfx("start");
        toast("START!");
      }

      function setPaused(p){
        if (!running || finished) return;
        paused = p;

        if (paused){
          setStatus("pause");
          sfx("pause");
          // stop scheduling (keep already scheduled sounds) and freeze performance clock
          if (audioCtx){
            // We can't truly pause scheduled audio; instead pause the game clock by adjusting songStartTime.
            // We shift songStartTime forward by paused duration upon resume.
          }
          pausePerf = now();
          showOverlay("PAUSED", "いつでも再開できます。<br>（スマホは画面タップでもOK）", "Resume");
          ovSmall.textContent = "再開：P / 画面タップ / Start";
        }else{
          setStatus("run");
          sfx("resume");
          hideOverlay();

          // adjust clocks
          const pausedMs = now() - pausePerf;
          pauseAccum += pausedMs;

          if (audioCtx){
            // shift songStartTime forward by paused duration to keep audio+chart aligned
            const shift = pausedMs / 1000;
            songStartTime += shift;
            // restart scheduler safely
            if (!songRunning && audioCtx.currentTime < schedEndTime){
              songRunning = true;
              clearInterval(schedTimer);
              schedTimer = setInterval(() => {
                if (!songRunning) return;
                const t0 = audioCtx.currentTime;
                const lookAhead = 0.18;
                scheduleMusic(t0, t0 + lookAhead);
                if (t0 > schedEndTime){
                  songRunning = false;
                  clearInterval(schedTimer);
                }
              }, 60);
            }
          }
        }
      }

      // ===== Rendering =====
      function hexToRgb(hex){
        const s = String(hex).trim();
        if (!s.startsWith("#")) return {r:255,g:255,b:255};
        const h = s.slice(1);
        if (h.length === 3){
          const r = parseInt(h[0]+h[0],16), g = parseInt(h[1]+h[1],16), b = parseInt(h[2]+h[2],16);
          return {r,g,b};
        }
        if (h.length >= 6){
          const r = parseInt(h.slice(0,2),16), g = parseInt(h.slice(2,4),16), b = parseInt(h.slice(4,6),16);
          return {r,g,b};
        }
        return {r:255,g:255,b:255};
      }
      function rgba(hex, a){
        const {r,g,b} = hexToRgb(hex);
        return `rgba(${r},${g},${b},${a})`;
      }

      function roundRect(c, x, y, w, h, r){
        const rr = Math.min(r, w/2, h/2);
        c.beginPath();
        c.moveTo(x+rr, y);
        c.arcTo(x+w, y, x+w, y+h, rr);
        c.arcTo(x+w, y+h, x, y+h, rr);
        c.arcTo(x, y+h, x, y, rr);
        c.arcTo(x, y, x+w, y, rr);
        c.closePath();
      }

      function draw(){
        if (!ctx) return;
        fitCanvas();

        const w = rect.cssW, h = rect.cssH;
        ctx.clearRect(0,0,w,h);

        // background glow
        const vg = ctx.createRadialGradient(w*0.5,h*0.25, 0, w*0.5,h*0.6, Math.max(w,h)*0.9);
        vg.addColorStop(0, "rgba(255,255,255,.07)");
        vg.addColorStop(1, "rgba(0,0,0,.35)");
        ctx.fillStyle = vg;
        ctx.fillRect(0,0,w,h);

        // playfield bounds
        const pad = Math.max(14, Math.min(w,h) * 0.045);
        const pfW = w - pad*2;
        const pfH = h - pad*2;
        const pfX = pad;
        const pfY = pad;

        // lane geometry
        const laneW = pfW / LANES;
        const hitY = pfY + pfH * HITLINE_Y;
        const noteSize = Math.max(16, laneW * 0.58);

        // panel frame
        ctx.save();
        roundRect(ctx, pfX, pfY, pfW, pfH, 18);
        ctx.fillStyle = "rgba(0,0,0,.18)";
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,.14)";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();

        // lanes
        for (let i=0; i<LANES; i++){
          const x = pfX + i*laneW;
          ctx.save();

          // lane base tint
          const c = LANE_COLS[i];
          const g = ctx.createLinearGradient(0, pfY, 0, pfY + pfH);
          g.addColorStop(0, rgba(c, 0.10));
          g.addColorStop(0.55, "rgba(255,255,255,.02)");
          g.addColorStop(1, rgba(c, 0.06));
          ctx.fillStyle = g;
          ctx.fillRect(x, pfY, laneW, pfH);

          // separators
          ctx.strokeStyle = "rgba(255,255,255,.08)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, pfY);
          ctx.lineTo(x, pfY + pfH);
          ctx.stroke();

          // hit glow
          const f = laneFlash[i];
          if (f > 0.001){
            const r = ctx.createRadialGradient(x + laneW*0.5, hitY, 0, x + laneW*0.5, hitY, laneW*0.9);
            r.addColorStop(0, rgba(c, 0.42 * f));
            r.addColorStop(1, "rgba(0,0,0,0)");
            ctx.fillStyle = r;
            ctx.fillRect(x, hitY - laneW, laneW, laneW*2);
          }

          ctx.restore();
        }

        // hit line
        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,.16)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(pfX, hitY);
        ctx.lineTo(pfX + pfW, hitY);
        ctx.stroke();

        // targets
        for (let i=0; i<LANES; i++){
          const x = pfX + i*laneW + laneW*0.5;
          const c = LANE_COLS[i];

          const r = noteSize*0.54;
          const glow = ctx.createRadialGradient(x, hitY, 0, x, hitY, r*1.6);
          glow.addColorStop(0, rgba(c, 0.24));
          glow.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = glow;
          ctx.fillRect(x - r*1.8, hitY - r*1.8, r*3.6, r*3.6);

          ctx.fillStyle = "rgba(255,255,255,.06)";
          ctx.beginPath();
          ctx.arc(x, hitY, r*0.78, 0, Math.PI*2);
          ctx.fill();

          ctx.strokeStyle = rgba(c, 0.72);
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(x, hitY, r*0.78, 0, Math.PI*2);
          ctx.stroke();
        }

        ctx.restore();

        // notes
        const t = running ? (currentTimeMs() + (settings.offsetMs|0)) : -99999;

        // only draw within window range
        const drawStart = Math.max(0, idxFirstActive - 80);
        const drawEnd = Math.min(chart.length, idxFirstActive + 220);

        for (let i=drawStart; i<drawEnd; i++){
          const n = chart[i];
          if (!n) continue;

          const dt = n.t - t;
          if (dt < -WINDOWS.miss - 260) continue;
          if (dt > LEAD_MS + 180) continue;

          // position: dt = LEAD => top; dt = 0 => hit line
          const prog = 1 - clamp(dt / LEAD_MS, 0, 1);
          const y = lerp(pfY + pfH*0.08, hitY, prog);

          const lane = n.lane;
          const cx = pfX + lane*laneW + laneW*0.5;
          const c = LANE_COLS[lane];

          // fade when judged
          let a = 1;
          if (n.judged){
            const age = (-dt - WINDOWS.miss) / 260; // after passing
            a = clamp(1 - age, 0, 1) * 0.55;
          }else{
            a = clamp(1 - Math.abs(dt) / (LEAD_MS*1.1), 0.30, 1);
          }

          const size = noteSize * (0.92 + prog * 0.06);
          const r = size * 0.22;

          // shadow/glow
          ctx.save();
          ctx.globalAlpha = a;

          const glow = ctx.createRadialGradient(cx, y, 0, cx, y, size*1.2);
          glow.addColorStop(0, rgba(c, 0.30));
          glow.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = glow;
          ctx.fillRect(cx - size*1.4, y - size*1.4, size*2.8, size*2.8);

          // block
          const x = cx - size/2;
          const yy = y - size/2;
          const g = ctx.createLinearGradient(x, yy, x+size, yy+size);
          g.addColorStop(0, rgba(c, 0.95));
          g.addColorStop(0.55, rgba(c, 0.70));
          g.addColorStop(1, rgba(c, 0.42));

          roundRect(ctx, x, yy, size, size, r);
          ctx.fillStyle = g;
          ctx.fill();

          ctx.lineWidth = Math.max(1, size * 0.07);
          ctx.strokeStyle = "rgba(255,255,255,.18)";
          ctx.stroke();

          // pixel sparkle
          ctx.globalAlpha = a * 0.7;
          ctx.fillStyle = "rgba(255,255,255,.18)";
          ctx.fillRect(x + size*0.18, yy + size*0.18, Math.max(2, size*0.10), Math.max(2, size*0.10));

          ctx.restore();
        }

        // top HUD-ish text
        ctx.save();
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = "rgba(255,255,255,.75)";
        ctx.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue('--pixel');
        ctx.textBaseline = "top";
        const leftText = `BPM ${BPM} / ${settings.diff.toUpperCase()}`;
        const timeSec = clamp(t/1000, 0, SONG_SEC);
        const rightText = running ? `${timeSec.toFixed(1)}s / ${SONG_SEC.toFixed(0)}s` : `READY`;
        ctx.fillText(leftText, pfX + 10, pfY + 10);

        const m = ctx.measureText(rightText);
        ctx.fillText(rightText, pfX + pfW - m.width - 10, pfY + 10);
        ctx.restore();

        // end fade when finished
        if (running && !paused){
          const elapsed = (audioCtx ? (audioCtx.currentTime - songStartTime) : (t/1000));
          if (elapsed >= SONG_SEC){
            finishGame();
          }
        }
      }

      // ===== Loop =====
      function tick(){
        const t = now();
        const dt = Math.min(60, t - lastFrameT);
        lastFrameT = t;

        // decay lane flash
        for (let i=0; i<LANES; i++){
          laneFlash[i] = Math.max(0, laneFlash[i] - dt * 0.0065);
        }

        if (running && !paused && !finished){
          missPassedNotes();
        }

        draw();
        requestAnimationFrame(tick);
      }

      // ===== Input =====
      const KEYMAP = {
        d: 0, D: 0,
        f: 1, F: 1,
        j: 2, J: 2,
        k: 3, K: 3
      };

      function onKeyDown(e){
        if (e.repeat) return;
        const k = e.key;

        if (k === "p" || k === "P" || k === "Escape"){
          if (running && !finished){
            setPaused(!paused);
          }
          return;
        }

        if (!running && (k === "Enter" || k === " ")){
          e.preventDefault();
          startViaUI();
          return;
        }
        if (finished && (k === "Enter" || k === " ")){
          e.preventDefault();
          startViaUI();
          return;
        }

        const lane = KEYMAP[k];
        if (lane !== undefined){
          e.preventDefault();
          hitLane(lane);
          flashPad(lane);
        }
      }

      window.addEventListener("keydown", onKeyDown, { passive:false });

      function flashPad(lane){
        const btn = pads[lane];
        if (!btn) return;
        btn.classList.add("hit");
        clearTimeout(btn._hitT);
        btn._hitT = setTimeout(() => btn.classList.remove("hit"), 90);
      }

      pads.forEach(btn => {
        const lane = Number(btn.getAttribute("data-lane"));
        let rep = 0;

        btn.addEventListener("pointerdown", async (e) => {
          e.preventDefault();
          flashPad(lane);

          // Start if not running
          if (!running || finished){
            await startViaUI();
            // after starting, also register hit if immediately
            if (running && !paused) hitLane(lane);
            return;
          }

          if (paused){
            setPaused(false);
            return;
          }

          hitLane(lane);

          clearInterval(rep);
          rep = setInterval(() => {
            // optional repeated taps for accessibility (very gentle)
            // but avoid unfair auto; just a tiny assist on easy
            if (settings.diff === "easy" && running && !paused) hitLane(lane);
          }, 260);
        }, { passive:false });

        const stop = () => { clearInterval(rep); rep = 0; };
        btn.addEventListener("pointerup", stop, { passive:true });
        btn.addEventListener("pointercancel", stop, { passive:true });
        btn.addEventListener("pointerleave", stop, { passive:true });
      });

      // Tap stage to resume/pause or hit center-lane based on x
      stageWrap.addEventListener("pointerdown", (e) => {
        if (overlay && !overlay.hidden){
          // overlay click handled by buttons; still allow tap-to-resume
          if (paused && running && !finished){
            setPaused(false);
          }
          return;
        }

        if (!running || finished) return;
        if (paused){
          setPaused(false);
          return;
        }

        const r = stageWrap.getBoundingClientRect();
        const x = e.clientX - r.left;
        const lane = clamp(Math.floor((x / r.width) * LANES), 0, LANES-1);
        hitLane(lane);
        flashPad(lane);
      }, { passive:true });

      // Auto pause on visibility change (live/commute friendly)
      document.addEventListener("visibilitychange", () => {
        if (document.hidden){
          if (running && !paused && !finished){
            setPaused(true);
            toast("自動一時停止");
          }
        }
      });

      // ===== Buttons / Overlay =====
      async function startViaUI(){
        try{
          syncSettingsFromUI();

          const ok = await unlockAudio();
          if (!ok){
            toast("音声の初期化に失敗しました（ブラウザ設定）", 2400);
          }

          ensureAudio();
          setVolumes();

          // always restart game (simple and reliable)
          stopMusic();
          startGame();
          if (audioCtx){
            // Ensure fresh schedule start
            startMusic();
          }
          return true;
        }catch(err){
          console.error(err);
          setStatus("dead");
          showOverlay("ERROR", "初期化に失敗しました。ページを再読み込みしてください。", "Reload");
          ovMain.onclick = () => location.reload();
          toast("エラー: " + (err && err.message ? err.message : "Unknown"), 3000);
          return false;
        }
      }

      function syncSettingsFromUI(){
        settings.diff = selDiff.value;
        settings.offsetMs = Number(rngOffset.value) | 0;
        settings.vol = clamp(Number(rngVol.value) / 100, 0, 1);
        valOffset.textContent = `${settings.offsetMs|0}ms`;
        valVol.textContent = `${Math.round(settings.vol*100)}%`;
        persistSettings();
        setVolumes();
      }

      btnStart.addEventListener("click", () => startViaUI());
      btnPause.addEventListener("click", () => {
        if (!running || finished){
          startViaUI();
          return;
        }
        setPaused(!paused);
      });

      btnSound.addEventListener("click", async () => {
        settings.sound = !settings.sound;
        persistSettings();
        syncSettingsUI();
        setVolumes();
        if (settings.sound){
          await unlockAudio();
          sfx("great");
          toast("Sound: On");
        }else{
          toast("Sound: Off");
        }
      });

      ovMain.addEventListener("click", async () => {
        if (ovMain.textContent.toLowerCase().includes("reload")){
          location.reload();
          return;
        }
        await startViaUI();
      });

      ovHow.addEventListener("click", () => {
        showOverlay(
          "HOW TO PLAY",
          "ノーツがラインに重なる瞬間にタップ！<br>" +
          "判定：<b>PERFECT</b> / <b>GREAT</b> / <b>GOOD</b> / <b>MISS</b><br>" +
          "ずれたら Timing Offset を調整して、会場でも気持ちよく叩こう。",
          "Start"
        );
        ovSmall.textContent = "キー：D F J K ／ 停止：P";
      });

      selDiff.addEventListener("change", () => {
        settings.diff = selDiff.value;
        persistSettings();
        toast("Difficulty: " + settings.diff);
      });

      rngOffset.addEventListener("input", () => {
        settings.offsetMs = Number(rngOffset.value) | 0;
        valOffset.textContent = `${settings.offsetMs|0}ms`;
      });
      rngOffset.addEventListener("change", () => persistSettings());

      rngVol.addEventListener("input", () => {
        settings.vol = clamp(Number(rngVol.value)/100, 0, 1);
        valVol.textContent = `${Math.round(settings.vol*100)}%`;
        setVolumes();
      });
      rngVol.addEventListener("change", () => persistSettings());

      btnRegen.addEventListener("click", () => {
        chart = buildChart(settings.diff);
        resetRun();
        updateUI();
        toast("Chart rebuilt");
        if (running && !paused && !finished){
          // keep timing; do not restart audio
        }else{
          showOverlay("READY?", "譜面を作り直しました。<br>Startでプレイ！", "Start");
          setStatus("ready");
        }
      });

      btnResetHigh.addEventListener("click", () => {
        highScore = 0;
        uiHigh.textContent = "0";
        if (LS) saveJSON(KEYS.high, 0);
        toast("High score reset");
      });

      // Resize
      const ro = new ResizeObserver(() => {
        try { fitCanvas(); draw(); } catch(_) {}
      });
      ro.observe(stageWrap);

      // ===== Init =====
      function init(){
        if (!ctx){
          setStatus("dead");
          showOverlay("ERROR", "Canvasが利用できません。別のブラウザでお試しください。", "Reload");
          ovMain.onclick = () => location.reload();
          return;
        }

        syncSettingsUI();
        setStatus("ready");

        // prebuild chart
        chart = buildChart(settings.diff);
        resetRun();
        updateUI();

        // initial canvas sizing & draw
        fitCanvas();
        draw();

        // start loop
        lastFrameT = now();
        requestAnimationFrame(tick);

        // friendly hint
        if (!LS){
          toast("ローカル保存が無効です（ハイスコアが保持されない場合があります）", 2400);
        }
      }

      try{
        init();
      }catch(err){
        console.error(err);
        setStatus("dead");
        showOverlay("ERROR", "初期化に失敗しました。ページを再読み込みしてください。", "Reload");
        ovMain.onclick = () => location.reload();
        toast("エラー: " + (err && err.message ? err.message : "Unknown"), 3000);
      }
    })();
  </script>
</body>
</html>
